

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>hdiprep.HDIprep.hdi_prep &mdash; miaaim 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: 5DADE2" >
          

          
            <a href="../../../index.html" class="icon icon-home"> miaaim
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Nextflow User Guide / Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#linux-os-x">Linux / OS X</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#windows">Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#installing-miaaim-in-python">Installing MIAAIM in Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start.html">Quick Start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../quick_start.html#prototype-001">prototype-001</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../quick_start.html#download-data">Download Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick_start.html#image-preprocessing">Image Preprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../quick_start.html#image-registration">Image Registration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../directory.html">Folder Structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../directory.html#input">input</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../directory.html#hdiprep">hdiprep</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../directory.html#hdireg">hdireg</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../directory.html#docs">docs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../workflows.html#image-preparation-hdiprep">Image Preparation (HDIprep)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../workflows.html#yaml-parameter-file-input-basics">YAML Parameter File Input Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../workflows.html#high-parameter-image-processing">High-Parameter Image Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../workflows.html#histological-image-processing">Histological Image Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../workflows.html#hdiprep-implementation-guide">HDIprep Implementation Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../workflows.html#image-registration-hdireg">Image Registration (HDIreg)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../workflows.html#hdireg-implementation-guide">HDIreg Implementation Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../workflows.html#tissue-state-modelling-patchmap">Tissue State Modelling (PatchMAP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../workflows.html#cross-system-tissue-information-transfer-i-patchmap">Cross-System/Tissue Information Transfer (i-PatchMAP)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../parameters.html">Parameter Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../parameters.html#nextflow">Nextflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../parameters.html#hdiprep">HDIprep</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../parameters.html#hdireg">HDIreg</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration.html">Configuration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../configuration.html#docker-singularity-containers">Docker/Singularity Containers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../configuration.html#resource-allocation">Resource Allocation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../configuration.html#memory">Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../configuration.html#cpu">CPU</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../configuration.html#preset-resource-allocation-options">Preset Resource Allocation Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#adding-imaging-modalities">Adding Imaging Modalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#importing-new-modalities-adding-file-formats">Importing New Modalities / Adding File Formats</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">MIAAIM in Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../python.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../python.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../python.html#usage-without-docker-install-with-pip">Usage without Docker / Install with Pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../python.html#reproducibility-with-pip">Reproducibility with Pip</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../python.html#docker">Docker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../python.html#hdi-utility-functions-hdi-utils">HDI Utility Functions (hdi-utils)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../python-workflows.html">Workflow Implementations in Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../python-workflows.html#image-preparation-hdiprep">Image Preparation (HDIprep)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../python-workflows.html#steady-state-umap-compression">Steady-state UMAP compression</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python-workflows.html#histological-image-processing">Histological Image Processing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../python-workflows.html#image-registration-hdireg">Image Registration (HDIreg)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../python-workflows.html#elastix">elastix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../python-workflows.html#transformix">transformix</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../python-workflows.html#tissue-state-modeling-patchmap">Tissue State Modeling (PatchMAP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../python-workflows.html#cross-system-tissue-information-transfer-i-patchmap">Cross-System/Tissue Information Transfer (i-PatchMAP)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../jupyter.html">Jupyter Notebook Zoo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../jupyter.html#image-preparation-hdiprep">Image Preparation (HDIprep)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jupyter.html#image-registration-hdireg">Image Registration (HDIreg)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../jupyter.html#id1">Image Registration (HDIreg)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#image-preparation-hdiprep">Image Preparation (HDIprep)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#module-hdiprep.HDIprep.hdi_prep">hdi_prep</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#module-hdiprep.HDIprep.utils">utils</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#image-registration-hdireg">Image Registration (HDIreg)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#module-hdireg.HDIreg.elastix">elastix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#module-hdireg.HDIreg.transformix">transformix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api.html#id7">utils</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#tissue-state-modeling-patchmap">Tissue State Modeling (PatchMAP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#cross-system-tissue-information-transfer-i-patchmap">Cross-System/Tissue Information Transfer (i-PatchMAP)</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Background on MIAAIM</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../elastix.html">Elastix Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../elastix.html#registration-parameter-files-elastix">Registration Parameter Files (Elastix)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../elastix.html#multi-channel-input">Multi-channel Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../elastix.html#single-channel-input">Single-channel Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../elastix.html#help-the-registration-with-manual-landmarks">Help the Registration with Manual Landmarks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../elastix.html#outputs">Outputs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../elastix.html#applying-transformations-transformix">Applying Transformations (Transformix)</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Roadmap</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../roadmap.html">MIAAIM Roadmap</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../roadmap.html#miaaim-0-0-1">MIAAIM 0.0.1</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#adding-imaging-modalities">Adding Imaging Modalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#importing-new-modalities-adding-file-formats">Importing New Modalities / Adding File Formats</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">FAQs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../faqs.html">FAQs</a></li>
</ul>
<p class="caption"><span class="caption-text">Contact</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact Information</a></li>
</ul>
<p class="caption"><span class="caption-text">Funding</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../funding.html">Funding</a></li>
</ul>
<p class="caption"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>
<p class="caption"><span class="caption-text">Acknowledgements</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../acknowledgements.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">miaaim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>hdiprep.HDIprep.hdi_prep</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hdiprep.HDIprep.hdi_prep</h1><div class="highlight"><pre>
<span></span><span class="c1"># Class for merging data within a modality</span>
<span class="c1"># Developer: Joshua M. Hess, BSc</span>
<span class="c1"># Developed at the Vaccine &amp; Immunotherapy Center, Mass. General Hospital</span>

<span class="c1"># Import external moduless</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">umap</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">skimage</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_random_state</span><span class="p">,</span> <span class="n">extmath</span><span class="p">,</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="n">literal_eval</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">uncertainties.unumpy</span> <span class="k">as</span> <span class="nn">unp</span>
<span class="kn">import</span> <span class="nn">uncertainties</span> <span class="k">as</span> <span class="nn">unc</span>
<span class="kn">from</span> <span class="nn">hdiutils.HDIimport</span> <span class="kn">import</span> <span class="n">hdi_reader</span>

<span class="c1"># Import custom modules</span>
<span class="kn">from</span> <span class="nn">.fuzzy_operations</span> <span class="kn">import</span> <span class="n">FuzzySetCrossEntropy</span>
<span class="kn">from</span> <span class="nn">.morphology</span> <span class="kn">import</span> <span class="n">MedFilter</span><span class="p">,</span> <span class="n">Opening</span><span class="p">,</span> <span class="n">Closing</span><span class="p">,</span> <span class="n">NonzeroSlice</span><span class="p">,</span> <span class="n">Thresholding</span><span class="p">,</span> <span class="n">MorphFill</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Exp</span><span class="p">,</span> <span class="n">CreateHyperspectralImage</span><span class="p">,</span> <span class="n">CreateHyperspectralImageRectangular</span><span class="p">,</span> <span class="n">ExportNifti</span>


<span class="k">def</span> <span class="nf">find_ab_params</span><span class="p">(</span><span class="n">spread</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">curve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span>

    <span class="n">xv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">spread</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
    <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">yv</span><span class="p">[</span><span class="n">xv</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">yv</span><span class="p">[</span><span class="n">xv</span> <span class="o">&gt;=</span> <span class="n">min_dist</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">xv</span><span class="p">[</span><span class="n">xv</span> <span class="o">&gt;=</span> <span class="n">min_dist</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">spread</span><span class="p">)</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">covar</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">check_base_object</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>

    <span class="c1"># Handle all the optional plotting arguments, setting default</span>
    <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">base</span><span class="o">.</span><span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">base</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">find_ab_params</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">spread</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">min_dist</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">a</span>
        <span class="n">base</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">b</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">init</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_initial_alpha</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">learning_rate</span>
    <span class="n">base</span><span class="o">.</span><span class="n">_validate_parameters</span><span class="p">()</span>
    <span class="c1"># return checked umap object</span>
    <span class="k">return</span> <span class="n">base</span>

<span class="k">def</span> <span class="nf">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>

    <span class="n">alt_embed</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">umap_</span><span class="o">.</span><span class="n">simplicial_set_embedding</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_raw_data</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span>
        <span class="n">n_components</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
        <span class="n">initial_alpha</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_initial_alpha</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span>
        <span class="n">b</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_b</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">repulsion_strength</span><span class="p">,</span>
        <span class="n">negative_sample_rate</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">negative_sample_rate</span><span class="p">,</span>  <span class="c1"># Default umap behavior is n_epochs None -- converts to 0</span>
        <span class="n">n_epochs</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">init</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">init</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">check_random_state</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
        <span class="n">metric</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_input_distance_func</span><span class="p">,</span>
        <span class="n">metric_kwds</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_metric_kwds</span><span class="p">,</span>
        <span class="n">densmap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">densmap_kwds</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">output_dens</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_metric</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_output_distance_func</span><span class="p">,</span>
        <span class="n">output_metric_kwds</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">_output_metric_kwds</span><span class="p">,</span>
        <span class="n">euclidean_output</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">output_metric</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="s2">&quot;l2&quot;</span><span class="p">),</span>
        <span class="n">parallel</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># return embedding</span>
    <span class="k">return</span> <span class="n">alt_embed</span>


<span class="c1"># Create a class for storing multiple datasets for a single modality</span>
<div class="viewcode-block" id="IntraModalityDataset"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset">[docs]</a><span class="k">class</span> <span class="nc">IntraModalityDataset</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Merge HDIreader classes storing imaging datasets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_HDIimports: list of length (n_samples)</span>
<span class="sd">        Merges input HDIreader objects to be merged into single class.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Initialized class objects:</span>

<span class="sd">    * self.set_dict: dictionary</span>
<span class="sd">        Dictionary containing each input samples filename as the key.</span>

<span class="sd">    * self.umap_object: object of class UMAP</span>
<span class="sd">        Stores any UMAP class objects after running UMAP.</span>

<span class="sd">    * self.umap_embeddings: dictionary</span>
<span class="sd">        Dictionary storing UMAP embeddings for each input sample.</span>

<span class="sd">    * self.umap_optimal_dim: integer</span>
<span class="sd">        Specifies steady state embedding dimensionality for UMAP.</span>

<span class="sd">    * self.processed_images_export: None or dictionary after ``ExportNifti1``</span>
<span class="sd">        Dictionary that links input file names with new export file names.</span>

<span class="sd">    * self.landmarks: integer</span>
<span class="sd">        Specifies number of landmarks to use for steady state embedding dimensionality</span>
<span class="sd">        estimation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create initialization</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_HDIimports</span><span class="p">):</span>

        <span class="c1"># Create objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_optimal_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_images_export</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Iterate through the list of HDIimports and add them to the set dictionary</span>
        <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">list_of_HDIimports</span><span class="p">:</span>
            <span class="c1"># Update the dictionary with keys being filenames</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dat</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span> <span class="n">dat</span><span class="p">})</span>

    <span class="c1"># Create dimension reduction method with UMAP</span>
<div class="viewcode-block" id="IntraModalityDataset.RunUMAP"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.RunUMAP">[docs]</a>    <span class="k">def</span> <span class="nf">RunUMAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an embedding of high-dimensional imaging data. Each</span>
<span class="sd">        pixel will be represented by its coordinates in the UMAP projection</span>
<span class="sd">        space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs: arguments passed to UMAP.</span>
<span class="sd">            Important arguments:</span>

<span class="sd">            * n_neighbors: integer</span>
<span class="sd">                Specifies number of nearest neighbors.</span>

<span class="sd">            * random_state: integer</span>
<span class="sd">                Specifies random state for reproducibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.umap_embeddings: dictionary</span>
<span class="sd">            Stores umap coordinates for each input file as the dictionary key.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a dictionary to store indices in</span>
        <span class="n">file_idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a counter</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create a list to store data tables in</span>
        <span class="n">pixel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create a blank frame</span>
        <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get the number of rows in the spectrum table</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># update the list of concatenation indices with filename</span>
            <span class="n">file_idx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span><span class="p">)})</span>
            <span class="c1"># Update the index</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span>

            <span class="c1"># Get the spectrum</span>
            <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="p">])</span>
            <span class="c1"># Clear the old pixel table from memory</span>
            <span class="c1"># hdi_imp.hdi.data.pixel_table = None</span>

        <span class="c1"># Set up UMAP parameters</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>

        <span class="c1"># Handle all the optional plotting arguments, setting default</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">check_base_object</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="c1"># Print update for this dimension</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Embedding in dimension &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">n_components</span><span class="p">))</span>
        <span class="c1"># Use previous simplicial set and embedding components to embed in higher dimension</span>
        <span class="n">alt_embed</span> <span class="o">=</span> <span class="n">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="c1"># update embedding</span>
        <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span> <span class="o">=</span> <span class="n">alt_embed</span>
        <span class="c1"># Unravel the UMAP embedding for each sample</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">file_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Check to see if file has subsampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Extract the corresponding index from  UMAP embedding with subsample coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise use the full coordinates list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># Here, ensure that the appropriate order for the embedding is given (c-style...imzml parser is fortran)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="c1"># Update the transform mode</span>
        <span class="n">base</span><span class="o">.</span><span class="n">transform_mode</span> <span class="o">=</span> <span class="s2">&quot;embedding&quot;</span>
        <span class="c1"># Add the umap object to the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="o">=</span> <span class="n">base</span></div>

    <span class="c1"># Create dimension reduction method with UMAP</span>
<div class="viewcode-block" id="IntraModalityDataset.RunParametricUMAP"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.RunParametricUMAP">[docs]</a>    <span class="k">def</span> <span class="nf">RunParametricUMAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an embedding of high-dimensional imaging data using</span>
<span class="sd">        UMAP parametrized by neural network. Each</span>
<span class="sd">        pixel will be represented by its coordinates in the UMAP projection</span>
<span class="sd">        space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs: key word arguments passed to UMAP.</span>
<span class="sd">            Important arguments:</span>

<span class="sd">            * n_neighbors: integer</span>
<span class="sd">                Specifies number of nearest neighbors.</span>

<span class="sd">            * random_state: integer</span>
<span class="sd">                Specifies random state for reproducibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.umap_embeddings: dictionary</span>
<span class="sd">            Stores umap coordinates for each input file as the dictionary key.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a dictionary to store indices in</span>
        <span class="n">file_idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a counter</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create a list to store data tables in</span>
        <span class="n">pixel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create a blank frame</span>
        <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get the number of rows in the spectrum table</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># update the list of concatenation indices with filename</span>
            <span class="n">file_idx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span><span class="p">)})</span>
            <span class="c1"># Update the index</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span>

            <span class="c1"># Get the spectrum</span>
            <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="p">])</span>

        <span class="c1"># run parametric umap with no spectral landmark selection</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">parametric_umap</span><span class="o">.</span><span class="n">ParametricUMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>

        <span class="c1"># Unravel the UMAP embedding for each sample</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">file_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Check to see if file has subsampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Extract the corresponding index from  UMAP embedding with subsample coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise use the full coordinates list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># Here, ensure that the appropriate order for the embedding is given (c-style...imzml parser is fortran)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="c1"># Add the umap object to the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="o">=</span> <span class="n">base</span></div>


<div class="viewcode-block" id="IntraModalityDataset.RunOptimalUMAP"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.RunOptimalUMAP">[docs]</a>    <span class="k">def</span> <span class="nf">RunOptimalUMAP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span> <span class="n">landmarks</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">export_diagnostics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run UMAP over a range of dimensions to choose steady state embedding</span>
<span class="sd">        by fitting an exponential regression model to the fuzzy set cross entropy</span>
<span class="sd">        curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_range: tuple (low_dim, high_dim; Default: (1,11))</span>
<span class="sd">            Indicates a range of embedding dimensions.</span>

<span class="sd">        landmarks: integer (Default: 3000)</span>
<span class="sd">            Specifies number of landmarks to use for steady state embedding dimensionality</span>
<span class="sd">            estimation.</span>

<span class="sd">        export_diagnostics: Bool (Default: False)</span>
<span class="sd">            Indicates whether or not to export a csv file and jpeg image showing</span>
<span class="sd">            steady state embedding dimensionality reports. These report the</span>
<span class="sd">            normalized (0-1 range) fuzzy set cross entropy across the range</span>
<span class="sd">            of indicated dimensionalities.</span>

<span class="sd">        output_dir: string (Default: None)</span>
<span class="sd">            Path to export data to if exporting diagnostic images and plots.</span>

<span class="sd">        n_jobs: integer (Default: 1)</span>
<span class="sd">            Path to export data to if exporting diagnostic images and plots.</span>

<span class="sd">        kwargs: key word arguments passed to UMAP.</span>
<span class="sd">            Important arguments:</span>

<span class="sd">            * n_neighbors: integer</span>
<span class="sd">                Specifies number of nearest neighbors.</span>

<span class="sd">            * random_state: integer</span>
<span class="sd">                Specifies random state for reproducibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check for landmarks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">landmarks</span>

        <span class="c1"># Create a dictionary to store indices in</span>
        <span class="n">file_idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a counter</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create a list to store data tables in</span>
        <span class="n">pixel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create a blank frame</span>
        <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get the number of rows in the spectrum table</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># update the list of concatenation indices with filename</span>
            <span class="n">file_idx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span><span class="p">)})</span>
            <span class="c1"># Update the index</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span>

            <span class="c1"># Get the spectrum</span>
            <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="p">])</span>

        <span class="c1"># Create list to store the results in</span>
        <span class="n">ce_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a dictionary to store the embeddings in</span>
        <span class="n">embed_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Check to see if the dim_range is a string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dim_range</span> <span class="o">=</span> <span class="n">literal_eval</span><span class="p">(</span><span class="n">dim_range</span><span class="p">)</span>

        <span class="c1"># Set up the dimension range for UMAP</span>
        <span class="n">dim_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Run UMAP on the first iteration -- we will skip simplicial set construction in next iterations</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>

        <span class="c1"># Check for landmark subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Print update</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">landmarks</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; spectral landmarks...&quot;</span><span class="p">)</span>
                <span class="c1"># Calculate singular value decomposition</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">extmath</span><span class="o">.</span><span class="n">randomized_svd</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Calculate spectral clustering</span>
                <span class="n">kmeans</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span><span class="n">init_size</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#Get kmeans labels using the singular value decomposition and minibatch k means</span>
                <span class="n">kmean_lab</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="c1"># Get  mean values from clustering to define spectral centroids</span>
                <span class="n">means</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kmean_lab</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ClusterID&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">tmp_frame</span><span class="o">.</span><span class="n">index</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Get mean values from dataframe</span>
                <span class="n">tmp_centroids</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;ClusterID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Create simplicial set from centroided data</span>
                <span class="n">base_centroids</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_centroids</span><span class="p">)</span>

                <span class="c1"># Handle all the optional plotting arguments, setting default</span>
                <span class="n">base_centroids</span> <span class="o">=</span> <span class="n">check_base_object</span><span class="p">(</span><span class="n">base_centroids</span><span class="p">)</span>

                <span class="c1"># Iterate through each subsequent embedding dimension -- add +1 because we have already used range</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># adjust base number of components</span>
                    <span class="n">base_centroids</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">dim</span>
                    <span class="c1"># Print update for this dimension</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Embedding in dimension &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
                    <span class="c1"># Use previous simplicial set and embedding components to embed in higher dimension</span>
                    <span class="n">alt_embed</span> <span class="o">=</span> <span class="n">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base_centroids</span><span class="p">)</span>
                    <span class="c1"># Print update</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished embedding&quot;</span><span class="p">)</span>

                    <span class="c1"># Update the embedding dictionary</span>
                    <span class="n">embed_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">alt_embed</span><span class="p">})</span>

                    <span class="c1"># Compute the fuzzy set cross entropy</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">FuzzySetCrossEntropy</span><span class="p">(</span>
                        <span class="n">alt_embed</span><span class="p">,</span> <span class="n">base_centroids</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span> <span class="n">base_centroids</span><span class="o">.</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">n_jobs</span>
                    <span class="p">)</span>
                    <span class="c1"># Update list for now</span>
                    <span class="n">ce_res</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">cs</span><span class="p">})</span>

                <span class="c1"># Construct a dataframe from the dictionary of results</span>
                <span class="n">ce_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ce_res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Cross-Entropy&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># set base centroids to 0 to save memory</span>
                <span class="n">base_centroids</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Iterate through each subsequent embedding dimension -- add +1 because we have already used range</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># adjust base number of components</span>
                    <span class="n">base</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">dim</span>
                    <span class="c1"># Print update for this dimension</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Embedding in dimension &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
                    <span class="c1"># Use previous simplicial set and embedding components to embed in higher dimension</span>
                    <span class="n">alt_embed</span> <span class="o">=</span> <span class="n">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="c1"># Print update</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished embedding&quot;</span><span class="p">)</span>

                    <span class="c1"># Update the embedding dictionary</span>
                    <span class="n">embed_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">alt_embed</span><span class="p">})</span>

                    <span class="c1"># Compute the fuzzy set cross entropy</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">FuzzySetCrossEntropy</span><span class="p">(</span>
                        <span class="n">alt_embed</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">n_jobs</span>
                    <span class="p">)</span>
                    <span class="c1"># Update list for now</span>
                    <span class="n">ce_res</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">cs</span><span class="p">})</span>

                <span class="c1"># Construct a dataframe from the dictionary of results</span>
                <span class="n">ce_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ce_res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Cross-Entropy&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Print update</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding optimal embedding dimension through exponential fit...&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the min-max normalized cross-entropy</span>
        <span class="n">ce_res_norm</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">ce_res</span><span class="p">)</span>
        <span class="c1"># Convert back to pandas dataframe</span>
        <span class="n">ce_res_norm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">ce_res_norm</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Scaled Cross-Entropy&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dim_range</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get the metric values</span>
        <span class="n">met</span> <span class="o">=</span> <span class="n">ce_res_norm</span><span class="p">[</span><span class="s2">&quot;Scaled Cross-Entropy&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Get the x axis information</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">ce_res_norm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Fit the data using exponential function</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">Exp</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">met</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create parameters from scipy fit</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">unc</span><span class="o">.</span><span class="n">correlated_values</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span>

        <span class="c1"># Create a tuple indicating the 95% interval containing the asymptote in c</span>
        <span class="n">asympt</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># create equally spaced samples between range of dimensions</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

        <span class="c1"># use unumpy.exp to create samples</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">unp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">px</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span>
        <span class="c1"># extract expected values</span>
        <span class="n">nom</span> <span class="o">=</span> <span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="n">py</span><span class="p">)</span>
        <span class="c1"># extract stds</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">unp</span><span class="o">.</span><span class="n">std_devs</span><span class="p">(</span><span class="n">py</span><span class="p">)</span>

        <span class="c1"># Iterate through samples to find the instance that value falls in 95% c value</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">py</span><span class="p">)):</span>
            <span class="c1"># Extract the nominal value</span>
            <span class="n">tmp_nom</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
            <span class="c1"># check if nominal value falls within 95% CI for asymptote</span>
            <span class="k">if</span> <span class="n">asympt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tmp_nom</span> <span class="o">&lt;=</span> <span class="n">asympt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># break the loop</span>
                <span class="k">break</span>
        <span class="c1"># Extract the nominal value at this index -- round up (any float value lower is not observed -- dimensions are int)</span>
        <span class="n">opt_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">px</span><span class="p">[</span><span class="n">val</span><span class="p">]))</span>
        <span class="c1"># Print update</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal UMAP embedding dimension is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">opt_dim</span><span class="p">))</span>

        <span class="c1"># Check to see if exporting plot</span>
        <span class="k">if</span> <span class="n">export_diagnostics</span><span class="p">:</span>
            <span class="c1"># Ensure that an output directory is entered</span>
            <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Raise and error if no output</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please add an output directory -- none identified&quot;</span><span class="p">))</span>
            <span class="c1"># Create a path based on the output directory</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create image path</span>
                <span class="n">im_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;OptimalUMAP.jpeg&quot;</span><span class="p">))</span>
                <span class="c1"># Create csv path</span>
                <span class="n">csv_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;OptimalUMAP.csv&quot;</span><span class="p">))</span>

            <span class="c1"># Plot figure and save results</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="c1"># plot the fit value</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Curve&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># add 2 sigma uncertainty lines</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;95% CI&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># plot the observed values</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">met</span><span class="p">,</span> <span class="s2">&quot;ko&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Observed Data&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
            <span class="c1"># Change axis names</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Dimension&quot;</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Min-Max Scaled Cross-Entropy&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Optimal Dimension Estimation&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="c1"># plt.show()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">im_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>

            <span class="c1"># Export the metric values to csv</span>
            <span class="n">ce_res_norm</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">)</span>

        <span class="c1"># set base component dimensionality</span>
        <span class="n">base</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">opt_dim</span>
        <span class="c1"># check if landmarks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># implement umap on the tmp frame -- faster than centroids method</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">check_base_object</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="c1"># Use the optimal UMAP embedding to add to the class object</span>
            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span> <span class="o">=</span> <span class="n">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="c1"># otherwise update the embedding with the original</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span> <span class="o">=</span> <span class="n">embed_dict</span><span class="p">[</span><span class="n">opt_dim</span><span class="p">]</span>
        <span class="c1"># Update the transform mode</span>
        <span class="n">base</span><span class="o">.</span><span class="n">transform_mode</span> <span class="o">=</span> <span class="s2">&quot;embedding&quot;</span>

        <span class="c1"># Unravel the UMAP embedding for each sample</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">file_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Check to see if file has subsampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Extract the corresponding index from  UMAP embedding with subsample coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise use the full coordinates list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># Here, ensure that the appropriate order for the embedding is given (c-style...imzml parser is fortran)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="c1"># Add the umap object to the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="o">=</span> <span class="n">base</span>
        <span class="c1"># Update the optimal dimensionality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_optimal_dim</span> <span class="o">=</span> <span class="n">opt_dim</span></div>

<div class="viewcode-block" id="IntraModalityDataset.RunOptimalParametricUMAP"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.RunOptimalParametricUMAP">[docs]</a>    <span class="k">def</span> <span class="nf">RunOptimalParametricUMAP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span> <span class="n">landmarks</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">export_diagnostics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run parametric UMAP over a range of dimensions to choose steady state embedding</span>
<span class="sd">        by fitting an exponential regression model to the fuzzy set cross entropy</span>
<span class="sd">        curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim_range: tuple (low_dim, high_dim; Default: (1,11))</span>
<span class="sd">            Indicates a range of embedding dimensions.</span>

<span class="sd">        landmarks: integer (Default: 3000)</span>
<span class="sd">            Specifies number of landmarks to use for steady state embedding dimensionality</span>
<span class="sd">            estimation.</span>

<span class="sd">        export_diagnostics: Bool (Default: False)</span>
<span class="sd">            Indicates whether or not to export a csv file and jpeg image showing</span>
<span class="sd">            steady state embedding dimensionality reports. These report the</span>
<span class="sd">            normalized (0-1 range) fuzzy set cross entropy across the range</span>
<span class="sd">            of indicated dimensionalities.</span>

<span class="sd">        output_dir: string (Default: None)</span>
<span class="sd">            Path to export data to if exporting diagnostic images and plots.</span>

<span class="sd">        n_jobs: integer (Default: 1)</span>
<span class="sd">            Path to export data to if exporting diagnostic images and plots.</span>

<span class="sd">        kwargs: key word arguments passed to UMAP.</span>
<span class="sd">            Important arguments:</span>

<span class="sd">            * n_neighbors: integer</span>
<span class="sd">                Specifies number of nearest neighbors.</span>

<span class="sd">            * random_state: integer</span>
<span class="sd">                Specifies random state for reproducibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check for landmarks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="o">=</span> <span class="n">landmarks</span>

        <span class="c1"># Create a dictionary to store indices in</span>
        <span class="n">file_idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a counter</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create a list to store data tables in</span>
        <span class="n">pixel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create a blank frame</span>
        <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get the number of rows in the spectrum table</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># update the list of concatenation indices with filename</span>
            <span class="n">file_idx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span><span class="p">)})</span>
            <span class="c1"># Update the index</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nrows</span>

            <span class="c1"># Get the spectrum</span>
            <span class="n">tmp_frame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="p">])</span>

        <span class="c1"># Create list to store the results in</span>
        <span class="n">ce_res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Create a dictionary to store the neural network models in</span>
        <span class="n">model_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Check to see if the dim_range is a string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dim_range</span> <span class="o">=</span> <span class="n">literal_eval</span><span class="p">(</span><span class="n">dim_range</span><span class="p">)</span>

        <span class="c1"># Set up the dimension range for UMAP</span>
        <span class="n">dim_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Check for landmark subsampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Run UMAP on the first iteration -- we will skip simplicial set construction in next iterations</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">parametric_umap</span><span class="o">.</span><span class="n">ParametricUMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>
                <span class="c1"># Print update</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">landmarks</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; spectral landmarks...&quot;</span><span class="p">)</span>
                <span class="c1"># Calculate singular value decomposition</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">extmath</span><span class="o">.</span><span class="n">randomized_svd</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Calculate spectral clustering</span>
                <span class="n">kmeans</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span><span class="n">init_size</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span><span class="p">,</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#Get kmeans labels using the singular value decomposition and minibatch k means</span>
                <span class="n">kmean_lab</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="c1"># Get  mean values from clustering to define spectral centroids</span>
                <span class="n">means</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp_frame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">kmean_lab</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ClusterID&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">tmp_frame</span><span class="o">.</span><span class="n">index</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Get mean values from dataframe</span>
                <span class="n">tmp_centroids</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;ClusterID&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Create simplicial set from centroided data</span>
                <span class="n">base_centroids</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;graph&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_centroids</span><span class="p">)</span>

                <span class="c1"># Handle all the optional plotting arguments, setting default</span>
                <span class="n">base_centroids</span> <span class="o">=</span> <span class="n">check_base_object</span><span class="p">(</span><span class="n">base_centroids</span><span class="p">)</span>

                <span class="c1"># Iterate through each subsequent embedding dimension -- add +1 because we have already used range</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># adjust base number of components</span>
                    <span class="n">base_centroids</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">dim</span>
                    <span class="c1"># Print update for this dimension</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Embedding in dimension &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
                    <span class="c1"># Use previous simplicial set and embedding components to embed in higher dimension</span>
                    <span class="n">alt_embed</span> <span class="o">=</span> <span class="n">simplicial_set_embedding_HDIprep</span><span class="p">(</span><span class="n">base_centroids</span><span class="p">)</span>
                    <span class="c1"># Print update</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished embedding&quot;</span><span class="p">)</span>

                    <span class="c1"># Compute the fuzzy set cross entropy</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">FuzzySetCrossEntropy</span><span class="p">(</span>
                        <span class="n">alt_embed</span><span class="p">,</span> <span class="n">base_centroids</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span> <span class="n">base_centroids</span><span class="o">.</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">n_jobs</span>
                    <span class="p">)</span>
                    <span class="c1"># Update list for now</span>
                    <span class="n">ce_res</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">cs</span><span class="p">})</span>

                <span class="c1"># Construct a dataframe from the dictionary of results</span>
                <span class="n">ce_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ce_res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Cross-Entropy&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Iterate through each subsequent embedding dimension -- add +1 because we have already used range</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                    <span class="c1"># Print update for this dimension</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Embedding in dimension &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
                    <span class="c1"># Use previous simplicial set and embedding components to embed in higher dimension</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">parametric_umap</span><span class="o">.</span><span class="n">ParametricUMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span><span class="n">n_components</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>
                    <span class="c1"># Print update</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished embedding&quot;</span><span class="p">)</span>

                    <span class="c1"># Compute the fuzzy set cross entropy</span>
                    <span class="n">cs</span> <span class="o">=</span> <span class="n">FuzzySetCrossEntropy</span><span class="p">(</span>
                        <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">graph_</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">min_dist</span><span class="p">,</span> <span class="n">n_jobs</span>
                    <span class="p">)</span>
                    <span class="c1"># Update list for now</span>
                    <span class="n">ce_res</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">cs</span><span class="p">})</span>
                    <span class="c1">#update the model dictionary</span>
                    <span class="n">model_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">base</span><span class="p">})</span>

                <span class="c1"># Construct a dataframe from the dictionary of results</span>
                <span class="n">ce_res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ce_res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Cross-Entropy&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Print update</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finding optimal embedding dimension through exponential fit...&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the min-max normalized cross-entropy</span>
        <span class="n">ce_res_norm</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">ce_res</span><span class="p">)</span>
        <span class="c1"># Convert back to pandas dataframe</span>
        <span class="n">ce_res_norm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">ce_res_norm</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Scaled Cross-Entropy&quot;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dim_range</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get the metric values</span>
        <span class="n">met</span> <span class="o">=</span> <span class="n">ce_res_norm</span><span class="p">[</span><span class="s2">&quot;Scaled Cross-Entropy&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Get the x axis information</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">ce_res_norm</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Fit the data using exponential function</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">Exp</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">met</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># create parameters from scipy fit</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">unc</span><span class="o">.</span><span class="n">correlated_values</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span>

        <span class="c1"># Create a tuple indicating the 95% interval containing the asymptote in c</span>
        <span class="n">asympt</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># create equally spaced samples between range of dimensions</span>
        <span class="n">px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

        <span class="c1"># use unumpy.exp to create samples</span>
        <span class="n">py</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">unp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">px</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span>
        <span class="c1"># extract expected values</span>
        <span class="n">nom</span> <span class="o">=</span> <span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="n">py</span><span class="p">)</span>
        <span class="c1"># extract stds</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">unp</span><span class="o">.</span><span class="n">std_devs</span><span class="p">(</span><span class="n">py</span><span class="p">)</span>

        <span class="c1"># Iterate through samples to find the instance that value falls in 95% c value</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">py</span><span class="p">)):</span>
            <span class="c1"># Extract the nominal value</span>
            <span class="n">tmp_nom</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
            <span class="c1"># check if nominal value falls within 95% CI for asymptote</span>
            <span class="k">if</span> <span class="n">asympt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tmp_nom</span> <span class="o">&lt;=</span> <span class="n">asympt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># break the loop</span>
                <span class="k">break</span>
        <span class="c1"># Extract the nominal value at this index -- round up (any float value lower is not observed -- dimensions are int)</span>
        <span class="n">opt_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">px</span><span class="p">[</span><span class="n">val</span><span class="p">]))</span>
        <span class="c1"># Print update</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal UMAP embedding dimension is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">opt_dim</span><span class="p">))</span>

        <span class="c1"># Check to see if exporting plot</span>
        <span class="k">if</span> <span class="n">export_diagnostics</span><span class="p">:</span>
            <span class="c1"># Ensure that an output directory is entered</span>
            <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Raise and error if no output</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please add an output directory -- none identified&quot;</span><span class="p">))</span>
            <span class="c1"># Create a path based on the output directory</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create image path</span>
                <span class="n">im_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;OptimalUMAP.jpeg&quot;</span><span class="p">))</span>
                <span class="c1"># Create csv path</span>
                <span class="n">csv_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;OptimalUMAP.csv&quot;</span><span class="p">))</span>

            <span class="c1"># Plot figure and save results</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="c1"># plot the fit value</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Curve&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># add 2 sigma uncertainty lines</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;95% CI&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">nom</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># plot the observed values</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">met</span><span class="p">,</span> <span class="s2">&quot;ko&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Observed Data&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
            <span class="c1"># Change axis names</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Dimension&quot;</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Min-Max Scaled Cross-Entropy&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Optimal Dimension Estimation&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="c1"># plt.show()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">im_path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>

            <span class="c1"># Export the metric values to csv</span>
            <span class="n">ce_res_norm</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">)</span>

        <span class="c1">#check if landmarks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmarks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># implement parametric umap on optimal dimensionality</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">parametric_umap</span><span class="o">.</span><span class="n">ParametricUMAP</span><span class="p">(</span><span class="n">transform_mode</span><span class="o">=</span><span class="s2">&quot;embedding&quot;</span><span class="p">,</span><span class="n">n_components</span><span class="o">=</span><span class="n">opt_dim</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tmp_frame</span><span class="p">)</span>
        <span class="c1"># otherwise fill in with existing model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the optimal UMAP embedding to add to the class object</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">model_dict</span><span class="p">[</span><span class="n">opt_dim</span><span class="p">]</span>

        <span class="c1"># Unravel the UMAP embedding for each sample</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">file_idx</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># Check to see if file has subsampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Extract the corresponding index from  UMAP embedding with subsample coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise use the full coordinates list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="n">base</span><span class="o">.</span><span class="n">embedding_</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span>
                            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="c1"># Here, ensure that the appropriate order for the embedding is given (c-style...imzml parser is fortran)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="c1"># Add the umap object to the class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="o">=</span> <span class="n">base</span>
        <span class="c1"># Update the optimal dimensionality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">umap_optimal_dim</span> <span class="o">=</span> <span class="n">opt_dim</span></div>

    <span class="c1"># Add function for creating hyperspectral image from UMAP</span>
<div class="viewcode-block" id="IntraModalityDataset.SpatiallyMapUMAP"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.SpatiallyMapUMAP">[docs]</a>    <span class="k">def</span> <span class="nf">SpatiallyMapUMAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;rectangular&quot;</span><span class="p">,</span><span class="n">save_mem</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map UMAP projections into the spatial domain (2-dimensional) using</span>
<span class="sd">        each pixel&#39;s original XY positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: string (Default: &quot;rectangular&quot;)</span>
<span class="sd">            Type of mapping to use for reconstructing an image from the UMAP</span>
<span class="sd">            embeddings.</span>

<span class="sd">            Options include:</span>

<span class="sd">            * &quot;rectangular&quot;</span>
<span class="sd">                Use for images that do not have an associated mask with them. This</span>
<span class="sd">                is the fastest option for spatial reconstruction.</span>

<span class="sd">            * &quot;coordinate&quot;</span>
<span class="sd">                Use each pixel&#39;s XY coordinate to fill an array one pixel at a</span>
<span class="sd">                time. This must be used for images that contain masks or are</span>
<span class="sd">                not stored as rectangular arrays.</span>

<span class="sd">        save_mem: Bool (Default: True)</span>
<span class="sd">            Save memory by deleting reserves of full images and intermediate steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check to make sure that UMAP object in class is not empty</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Raise an error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Spatially mapping an embedding is not possible yet! Please run UMAP first.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># For now, create a dictionary to store the results in</span>
        <span class="n">results_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Run through each object in the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">locs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;working on &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span><span class="p">)</span>

            <span class="c1"># Check to see if there is subsampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Get the inverse pixels</span>
                <span class="n">inv_pix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># check for saving memory</span>
                <span class="k">if</span> <span class="n">save_mem</span><span class="p">:</span>
                    <span class="c1"># remove pixel unncessary portions of stored image</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sub_coordinates</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Create a mask based off array size and current UMAP data points</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_pix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                <span class="c1"># Create row data for scipy coo matrix (-1 index for 0-based python)</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inv_pix</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_pix</span><span class="p">))])</span>
                <span class="c1"># Create row data for scipy coo matrix (-1 index for 0-based python)</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inv_pix</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_pix</span><span class="p">))])</span>

                <span class="c1"># Create a sparse mask from data and row column indices</span>
                <span class="n">sub_mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">array_size</span>
                <span class="p">)</span>

                <span class="c1"># Remove the other objects used to create the mask to save memory</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">inv_pix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

                <span class="c1"># Read the file and use the mask to create complementary set of pixels</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="n">hdi_reader</span><span class="o">.</span><span class="n">HDIreader</span><span class="p">(</span>
                    <span class="n">path_to_data</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
                    <span class="n">path_to_markers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">subsample</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">mask</span><span class="o">=</span><span class="n">sub_mask</span><span class="p">,</span>
                    <span class="n">save_mem</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

                <span class="c1"># Remove the mask to save memory</span>
                <span class="n">sub_mask</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># print update</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transforming pixels into existing UMAP embedding of subsampled pixels...&quot;</span><span class="p">)</span>
                <span class="c1"># Run the new pixel table through umap transformer</span>
                <span class="n">embedding_projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_object</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                    <span class="n">new_data</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span>
                <span class="p">)</span>
                <span class="c1"># Add the projection to dataframe and coerce with existing embedding</span>
                <span class="n">embedding_projection</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">embedding_projection</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_table</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="c1"># Remove the new data to save memory</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Concatenate with existing UMAP object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">locs</span><span class="p">,</span> <span class="n">embedding_projection</span><span class="p">])</span>

                <span class="c1"># save memory do not store embedding twice</span>
                <span class="n">embedding_projection</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Reindex data frame to row major orientation</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="c1"># print update</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Reconstructing image...&#39;</span><span class="p">)</span>
            <span class="c1"># check for mask to use in reconstruction</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;rectangular&quot;</span><span class="p">:</span>
                <span class="c1"># Use the new embedding to map coordinates to the image</span>
                <span class="n">hyper_im</span> <span class="o">=</span> <span class="n">CreateHyperspectralImageRectangular</span><span class="p">(</span>
                    <span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
                    <span class="n">array_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">array_size</span><span class="p">,</span>
                    <span class="n">coordinates</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;coordinate&quot;</span><span class="p">:</span>
                <span class="c1"># use array reshaping (faster)</span>
                <span class="n">hyper_im</span> <span class="o">=</span> <span class="n">CreateHyperspectralImage</span><span class="p">(</span>
                    <span class="n">embedding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
                    <span class="n">array_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">array_size</span><span class="p">,</span>
                    <span class="n">coordinates</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">umap_embeddings</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spatial reconstruction method not supported.&quot;</span><span class="p">))</span>

            <span class="c1"># Update list</span>
            <span class="n">results_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="n">hyper_im</span><span class="p">})</span>

            <span class="c1"># add this hyperspectral image to the hdi_import object as processed_image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">hyper_im</span>

        <span class="c1"># print update</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished spatial mapping&quot;</span><span class="p">)</span></div>

        <span class="c1"># Return the resulting images</span>
        <span class="c1"># return results_dict</span>

    <span class="c1"># Create definition for image filtering and processing</span>
<div class="viewcode-block" id="IntraModalityDataset.ApplyManualMask"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.ApplyManualMask">[docs]</a>    <span class="k">def</span> <span class="nf">ApplyManualMask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply input mask to image. This function is</span>
<span class="sd">        primarily used on histology images and images that do not need dimension</span>
<span class="sd">        reduction. Dimension reduction with a mask will by default zero all other pixels</span>
<span class="sd">        in the image outside of the mask, but do not use this function if</span>
<span class="sd">        performing dimension reduction.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>
            <span class="c1"># Ensure that the image itself is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Use the mask on the image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">[</span><span class="o">~</span><span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">toarray</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Otherwise the processed image exists and now check the data type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Proceed to process the processed image as an array</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span>
                <span class="p">):</span>
                    <span class="c1"># Convert to array</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                    <span class="p">)</span>

                    <span class="c1"># Use the mask on the image</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">[</span>
                        <span class="o">~</span><span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># Turn the processed mask back to sparse matrix</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                        <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.MedianFilter"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.MedianFilter">[docs]</a>    <span class="k">def</span> <span class="nf">MedianFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Median filtering of images to remove salt and pepper noise.</span>
<span class="sd">        A circular disk is used for the filtering. Images that are not single channel</span>
<span class="sd">        are automatically converted to grayscale prior to filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_size: integer</span>
<span class="sd">            Size of disk to use for the median filter.</span>

<span class="sd">        parallel: Bool (Default: False)</span>
<span class="sd">            Use parallel processing with all available CPUs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">MedFilter</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span>

            <span class="c1"># Use the initiated image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the processed image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">MedFilter</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">filter_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.Threshold"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.Threshold">[docs]</a>    <span class="k">def</span> <span class="nf">Threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;otsu&quot;</span><span class="p">,</span> <span class="n">thresh_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Threshold grayscale images. Produces a sparse boolean</span>
<span class="sd">        mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        type: string (Default: &quot;otsu&quot;)</span>
<span class="sd">            Type of thresholding to use.</span>

<span class="sd">            Options include:</span>

<span class="sd">            * &quot;otsu&quot;</span>
<span class="sd">                Otsu automated thresholding.</span>

<span class="sd">            * &quot;manual&quot;</span>
<span class="sd">                Set manual threshold value.</span>

<span class="sd">        thresh_value: float (Default: None)</span>
<span class="sd">            Manual threshold to use if ``type`` is set to &quot;manual&quot;</span>

<span class="sd">        correction: float (Default: 1.0)</span>
<span class="sd">            Correct factor to multiply threshold by for more stringent thresholding.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Thresholding</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">thresh_value</span><span class="p">,</span> <span class="n">correction</span>
                <span class="p">)</span>

            <span class="c1"># Use the initiated image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the processed image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Thresholding</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">thresh_value</span><span class="p">,</span> <span class="n">correction</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.Open"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.Open">[docs]</a>    <span class="k">def</span> <span class="nf">Open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Morphological opening on boolean array (i.e., a mask).</span>
<span class="sd">        A circular disk is used for the filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_size: integer</span>
<span class="sd">            Size of disk to use for the median filter.</span>

<span class="sd">        parallel: Bool (Default: False)</span>
<span class="sd">            Use parallel processing with all available CPUs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Opening</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span>

            <span class="c1"># Use the initiated image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the processed image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Opening</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.Close"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.Close">[docs]</a>    <span class="k">def</span> <span class="nf">Close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Morphological closing on boolean array (i.e., a mask).</span>
<span class="sd">        A circular disk is used for the filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_size: integer</span>
<span class="sd">            Size of disk to use for the median filter.</span>

<span class="sd">        parallel: Bool (Default: False)</span>
<span class="sd">            Use parallel processing with all available CPUs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Closing</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span>

            <span class="c1"># Use the initiated image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the processed image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">Closing</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">disk_size</span><span class="p">,</span> <span class="n">parallel</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.Fill"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.Fill">[docs]</a>    <span class="k">def</span> <span class="nf">Fill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Morphological filling on a binary mask. Fills holes in the given mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If not, use the original image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">MorphFill</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span>
                <span class="p">)</span>

            <span class="c1"># Use the initiated image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use the processed image</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">MorphFill</span><span class="p">(</span>
                    <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="IntraModalityDataset.NonzeroBox"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.NonzeroBox">[docs]</a>    <span class="k">def</span> <span class="nf">NonzeroBox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use a nonzero indices of a binary mask to create a bounding box for</span>
<span class="sd">        the mask itself and for the original image. This isused so that</span>
<span class="sd">        a controlled amount of padding can be added to the edges of the images in</span>
<span class="sd">        a consistent manner.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Check to see if the preprocessed is initiated</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this iteration because the processed image must be present</span>
                <span class="k">continue</span>

            <span class="c1"># If all conditions are satisfied, use the slicing on the images</span>
            <span class="p">(</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">NonzeroSlice</span><span class="p">(</span>
                <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span>
            <span class="p">)</span></div>

    <span class="c1"># Create definition for image filtering and processing</span>
<div class="viewcode-block" id="IntraModalityDataset.ApplyMask"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.ApplyMask">[docs]</a>    <span class="k">def</span> <span class="nf">ApplyMask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply mask to image. This function is</span>
<span class="sd">        primarily used on histology images and images that do not need dimension</span>
<span class="sd">        reduction. Should be used after a series of morphological</span>
<span class="sd">        operations. This applies the resulting mask of thresholding and</span>
<span class="sd">        morphological operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip this image if there is no mask</span>
                <span class="k">continue</span>

            <span class="c1"># Create a temporary image based on the current image</span>
            <span class="n">tmp_im</span> <span class="o">=</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Use the mask on the image and replace the image with the masked image</span>
            <span class="n">tmp_im</span><span class="p">[</span><span class="o">~</span><span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="o">.</span><span class="n">toarray</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Set the processed image as the masked array</span>
            <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="o">=</span> <span class="n">tmp_im</span></div>

    <span class="c1"># Add function for exporting UMAP nifti image</span>
<div class="viewcode-block" id="IntraModalityDataset.ExportNifti1"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.IntraModalityDataset.ExportNifti1">[docs]</a>    <span class="k">def</span> <span class="nf">ExportNifti1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Export processed images resulting from UMAP and</span>
<span class="sd">        spatially mapping UMAP, or exporting processed histology images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir: string</span>
<span class="sd">            Path to output directory to store processed nifti image.</span>

<span class="sd">        padding: string of tuple of type integer (padx,pady; Default: None)</span>
<span class="sd">            Indicates height and length padding to add to the image before exporting.</span>

<span class="sd">        target_size: string of tuple of type integer (sizex,sizey; Default: None)</span>
<span class="sd">            Resize image using bilinear interpolation before exporting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create dictionary with connected file names</span>
        <span class="n">connect_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Iterate through the set dictionary</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">hdi_imp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Create an image name -- remove .ome in the name if it exists and add umap suffix</span>
            <span class="n">im_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">output_dir</span><span class="p">),</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">stem</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.ome.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_processed.nii&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Ensure that the mask is not none</span>
            <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Make sure the image exists</span>
                <span class="k">if</span> <span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Otherwise export the image</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Export the original image</span>
                    <span class="n">ExportNifti</span><span class="p">(</span><span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">im_name</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">target_size</span><span class="p">)</span>
            <span class="c1"># Otherwise export the processed image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use utils export nifti function</span>
                <span class="n">ExportNifti</span><span class="p">(</span><span class="n">hdi_imp</span><span class="o">.</span><span class="n">hdi</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">processed_image</span><span class="p">,</span> <span class="n">im_name</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">target_size</span><span class="p">)</span>
            <span class="c1"># Add exported file names to class object -- connect input file name with the exported name</span>
            <span class="n">connect_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="n">im_name</span><span class="p">})</span>

        <span class="c1"># Add the connecting dictionary to the class object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_images_export</span> <span class="o">=</span> <span class="n">connect_dict</span></div></div>

        <span class="c1"># return the dictionary of input names to output names</span>
        <span class="c1"># return connect_dict</span>


<span class="c1"># Define function for reading data with multiple input paths</span>
<div class="viewcode-block" id="CreateDataset"><a class="viewcode-back" href="../../../api.html#hdiprep.HDIprep.hdi_prep.CreateDataset">[docs]</a><span class="k">def</span> <span class="nf">CreateDataset</span><span class="p">(</span><span class="n">list_of_paths</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an intramodality imaging dataset based on a given list of paths</span>
<span class="sd">    for imaging files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    list_of_paths: list of length n_samples.</span>
<span class="sd">        Input data to concatenate into a single dataset. Each input dataset</span>
<span class="sd">        is of the class HDIreader from the hdiutils python package.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data: class object.</span>
<span class="sd">        Dataset with concatenated image data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create a list to store the hdi_reader sets in</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Iterate through each path</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_paths</span><span class="p">)):</span>
        <span class="c1"># Ensure that it is a pathlib object</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">list_of_paths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># Read the data using hdi_reader</span>
        <span class="n">p_dat</span> <span class="o">=</span> <span class="n">hdi_reader</span><span class="o">.</span><span class="n">HDIreader</span><span class="p">(</span><span class="n">path_to_data</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Append this p_dat to the data list</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_dat</span><span class="p">)</span>
    <span class="c1"># Concatenate the list of data to a single intramodality dataset</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">IntraModalityDataset</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
    <span class="c1"># Return the IntraModalityDataset</span>
    <span class="k">return</span> <span class="n">data</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Joshua Hess.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>